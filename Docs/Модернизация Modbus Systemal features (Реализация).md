# Реализация Modbus System Features (Архитектура v2.1)

Этот документ описывает реализованные архитектурные механизмы повышения надежности и производительности системы IIoT.

## Часть 1. Modbus Client (Edge Layer)

**Стек:** .NET 10 Worker Service, NModbus, Dapper, SQLite.

**Цель:** Обеспечить целостность данных при любых сбоях сети и автономность узла сбора (Edge Independence).

### 1.1. Dynamic Device List (Масштабируемость)
**Реализация:**
Модуль сбора данных (`ModbusWorker`) больше не использует хардкод IP-адресов.
- Используется `PeriodicTimer` для управления циклами опроса.
- При старте и периодически (согласно `ConfigReloadIntervalSec` из БД) сервис обновляет список активных устройств и настройки датчиков из таблиц `devices` / `sensor_settings`.
- Инженер может добавлять новые контроллеры ADAM-6017 "на лету" через веб-интерфейс, изменения подхватываются автоматически без перезапуска сервиса.

### 1.2. Local Caching (Buffer)
**Реализация:**
В случае недоступности основной БД (TimescaleDB), Modbus Collector переключается в режим буферизации.
- Данные сохраняются в локальную базу **SQLite** (`buffer.db`) в режиме **WAL (Write-Ahead Logging)** для высокой производительности.
- Фоновый поток `RunBufferFlusherLoop` периодически проверяет доступность сервера.
- При восстановлении связи происходит пакетная выгрузка данных (FIFO) в таблицу `metrics`, после чего буфер очищается.

### 1.3. Deadband (Фильтрация шума)
**Принцип:**
Исключение избыточной записи данных, если значение изменилось незначительно.
- Алгоритм: `Abs(Current - LastSaved) > Threshold * Range`.
- **Force Update:** Если значение не менялось в течение `DataHeartbeatSec` (напр. 600 с), принудительно пишется точка ("Heartbeat данных").
- Параметры Deadband настраиваются глобально через `system_config`.

### 1.4. System Heartbeat (Пульс сервисов)
**Таблица:** `system_status`
**Механизм:**
Сервис `ModbusWorker` в отдельном потоке `RunHealthLoop` обновляет свой статус в БД каждые 30 секунд.
- **Поля:** `service_name`, `status` (ONLINE, DEGRADED, CRITICAL), `last_sync`, `uptime`.
- API Gateway может использовать эти данные для мониторинга здоровья сборщика.

---

## Часть 2. Database Layer (TimescaleDB Storage)

**Цель:** Оптимизация хранения временных рядов и мгновенная аналитика.

### 2.1. High Performance Insert
**Реализация:**
Для записи метрик используется протокол **PostgreSQL Binary COPY** (через `Npgsql.BeginBinaryImportAsync`).
- Это обеспечивает максимальную скорость вставки, минуя накладные расходы на парсинг SQL INSERT.

### 2.2. Hypertable (`metrics`)
**Структура:**
Вместо обычной таблицы используется Hypertable TimescaleDB, партицированная по времени (`time`) и `sensor_id`.
- **Сжатие:** Включено (`timescaledb.compress`).
- **Эффективность:** Данные занимают в 10-15 раз меньше места.

### 2.2. Continuous Aggregates (`metrics_hourly`)
**Реализация:**
Материализованное представление для быстрой отрисовки исторических графиков.
- **Обновление:** Автоматическое политиками TimescaleDB.
- **Агрегаты:** `AVG`, `MAX`, `MIN`.

### 2.3. Data Lifecycle Management (Retention)
**Конфигурация:** Таблица `system_config`.
**Автоматизация:**
Хранимая процедура `prc_run_retention` удаляет старые чанки раз в сутки согласно настройкам.

---

## Часть 3. Web API Gateway & Logic

### 3.1. Embedded Frontend
**Оптимизация деплоя:**
API Gateway выступает также веб-сервером для статических файлов SPA (Vue 3). Это упрощает `docker-compose.yml`, убирая лишний Nginx контейнер.

### 3.2. Session Tracker
**Безопасность канала:**
Middleware, отслеживающий количество активных SignalR соединений. Если лимит (например, 10 IP) превышен, новые подключения отклоняются для защиты канала Cloudflare Tunnel.

### 3.3. Virtual Sensors Engine
**Тип данных:** `sensor_data_type = 'VIRTUAL'`.
- API вычисляет значение "на лету" по формуле из `sensor_settings`.

### 3.4. UI Configuration in DB
**Single Source of Truth:**
- Параметры отображения (`ui_config`) хранятся в БД, обеспечивая единый вид на Web и Mobile клиентах.