# Модернизация Modbus System Features (Архитектура v2.1)

Этот документ описывает ключевые архитектурные механизмы повышения надежности и производительности системы IIoT, согласованные с текущей схемой базы данных (`iiot_init.sql`).

## Часть 1. Modbus Client (Edge Layer)

**Цель:** Обеспечить целостность данных при любых сбоях сети и автономность узла сбора (Edge Independence).

### 1.1. Dynamic Device List (Масштабируемость)
**Реализация:**
Модуль сбора данных (`ModbusWorker`) больше не использует хардкод IP-адресов.
- При старте и периодически (или по команде через Redis/SignalR) сервис вычитывает список активных устройств из таблицы `devices`.
- Это позволяет Инженеру добавлять новые контроллеры ADAM-6017 "на лету" через веб-интерфейс.

### 1.2. Local Caching (Buffer)
**Реализация:**
В случае недоступности основной БД (TimescaleDB), Modbus Collector переключается в режим буферизации.
- Данные временно сохраняются в локальном файловом хранилище (SQLite или бинарный журнал) внутри контейнера.
- Фоновый поток ("Siphon") периодически проверяет доступность сервера.
- При восстановлении связи происходит пакетная выгрузка данных в таблицу `metrics`.

### 1.3. Deadband (Фильтрация шума)
**Принцип:**
Исключение избыточной записи данных, если значение изменилось незначительно.
- Алгоритм: `Abs(Current - LastSaved) > Threshold`.
- **Force Update:** Если значение не менялось в течение `MaxTimeInterval` (напр. 60 с), принудительно пишется точка ("Heartbeat данных").

### 1.4. System Heartbeat (Пульс сервисов)
**Таблица:** `system_status`
**Механизм:**
Каждый микросервис (Modbus Collector, API Gateway) периодически обновляет свой статус в БД.
- **Поля:** `service_name`, `status`, `last_sync`, `last_error`.
- API Gateway отслеживает эти статусы и генерирует алерт, если коллектор молчит более 2 минут.

---

## Часть 2. Database Layer (TimescaleDB Storage)

**Цель:** Оптимизация хранения временных рядов и мгновенная аналитика.

### 2.1. Hypertable (`metrics`)
**Структура:**
Вместо обычной таблицы используется Hypertable TimescaleDB, партицированная по времени (`time`) и `sensor_id`.
- **Сжатие:** Включено (`timescaledb.compress`).
- **Эффективность:** Данные занимают в 10-15 раз меньше места.

### 2.2. Continuous Aggregates (`metrics_hourly`)
**Реализация:**
Материализованное представление для быстрой отрисовки исторических графиков.
- **Обновление:** Автоматическое политиками TimescaleDB.
- **Агрегаты:** `AVG`, `MAX`, `MIN`.

### 2.3. Data Lifecycle Management (Retention)
**Конфигурация:** Таблица `system_config`.
**Автоматизация:**
Хранимая процедура `prc_run_retention` удаляет старые чанки раз в сутки согласно настройкам.

---

## Часть 3. Web API Gateway & Logic

### 3.1. Embedded Frontend
**Оптимизация деплоя:**
API Gateway выступает также веб-сервером для статических файлов SPA (Vue 3). Это упрощает `docker-compose.yml`, убирая лишний Nginx контейнер.

### 3.2. Session Tracker
**Безопасность канала:**
Middleware, отслеживающий количество активных SignalR соединений. Если лимит (например, 10 IP) превышен, новые подключения отклоняются для защиты канала Cloudflare Tunnel.

### 3.3. Virtual Sensors Engine
**Тип данных:** `sensor_data_type = 'VIRTUAL'`.
- API вычисляет значение "на лету" по формуле из `sensor_settings`.

### 3.4. UI Configuration in DB
**Single Source of Truth:**
- Параметры отображения (`ui_config`) хранятся в БД, обеспечивая единый вид на Web и Mobile клиентах.