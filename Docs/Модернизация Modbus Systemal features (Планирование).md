# Модернизация Modbus System Features (Архитектура v2.0)

Этот документ описывает ключевые архитектурные механизмы повышения надежности и производительности системы IIoT, согласованные с текущей схемой базы данных (`iiot_init.sql`).

## Часть 1. Modbus Client (Edge Layer)

**Цель:** Обеспечить целостность данных при любых сбоях сети и автономность узла сбора (Edge Independence).

### 1.1. Local Caching (Buffer)
**Реализация:**
В случае недоступности основной БД (TimescaleDB), Modbus Collector переключается в режим буферизации.
- Данные временно сохраняются в локальном файловом хранилище (SQLite или бинарный журнал) внутри контейнера.
- Фоновый поток ("Siphon") периодически проверяет доступность сервера.
- При восстановлении связи происходит пакетная выгрузка данных в таблицу `metrics`.

### 1.2. Deadband (Фильтрация шума)
**Принцип:**
Исключение избыточной записи данных, если значение изменилось незначительно.
- Алгоритм: `Abs(Current - LastSaved) > Threshold`.
- **Force Update:** Если значение не менялось в течение `MaxTimeInterval` (напр. 60 с), принудительно пишется точка, чтобы график оставался непрерывным ("Heartbeat данных").

### 1.3. System Heartbeat (Пульс сервисов)
**Таблица:** `system_status`
**Механизм:**
Каждый микросервис (Modbus Collector, API Gateway) периодически (раз в 30-60 с) обновляет свой статус в БД.
- **Поля:**
    - `service_name`: Идентификатор (напр. "ModbusCollector").
    - `status`: `ONLINE`, `DEGRADED`, `OFFLINE` (ENUM `system_service_status`).
    - `last_sync`: Timestamp последнего отклика.
    - `last_error`: Текст последней перехваченной ошибки.
- **Наблюдаемость:** Если `last_sync` старее 2 минут -> Сервис считается упавшим, UI показывает аллерт.

---

## Часть 2. Database Layer (TimescaleDB Storage)

**Цель:** Оптимизация хранения временных рядов и мгновенная аналитика.

### 2.1. Hypertable (`metrics`)
**Структура:**
Вместо обычной таблицы используется Hypertable TimescaleDB, партицированная по времени (`time`) и `sensor_id`.
- **Сжатие:** Включено (`timescaledb.compress`). Сегментирование по `sensor_id`.
- **Эффективность:** Данные занимают в 10-15 раз меньше места, чем в ванильном PostgreSQL.

### 2.2. Continuous Aggregates (`metrics_hourly`)
**Реализация:**
Материализованное представление для быстрой отрисовки исторических графиков (год, месяц).
- **Обновление:** Автоматическое, через политики TimescaleDB (`schedule_interval => '1 hour'`).
- **Агрегаты:** `AVG(value)`, `MAX(value)`, `MIN(value)`.
- **Преимущество:** Запрос за год возвращает ~8760 точек (по одной за час) вместо миллионов сырых записей.

### 2.3. Data Lifecycle Management (Retention)
**Конфигурация:** Таблица `system_config`.
**Автоматизация:**
Хранимая процедура `prc_run_retention` запускается планировщиком раз в сутки.
- Читает настройки `raw_retention_days` (по умолчанию 90) и `agg_retention_days` (по умолчанию 1825).
- Выполняет `drop_chunks` для удаления устаревших сегментов данных.
- Логирует результат выполнения в таблицу `maintenance_logs`.

---

## Часть 3. Web API Gateway & Logic

### 3.1. Virtual Sensors Engine
**Тип данных:** `sensor_data_type = 'VIRTUAL'`.
**Механизм:**
- В таблице `sensor_settings` для виртуальных каналов задается поле `formula` (напр. `(P1 + P2) / 2`).
- API вычисляет значение "на лету" при поступлении данных от физических датчиков или по таймеру.
- Для клиента виртуальный датчик неотличим от физического (прозрачный интерфейс).

### 3.2. SignalR Groups
**Оптимизация трафика:**
- API разделяет клиентов по группам подписки (например, "Dashboard", "Settings").
- "Живые" данные (`ReceiveMetrics`) рассылаются только тем клиентам, кто находится на экране мониторинга, снижая нагрузку на сеть.

### 3.3. UI Configuration in DB
**Single Source of Truth:**
- Визуальные параметры датчика (цвет, иконка, границы спидометра) хранятся в поле `sensor_settings.ui_config` (JSONB).
- Это гарантирует, что Веб-дашборд и Мобильное приложение показывают датчики одинаково, без хардкода на клиенте.
